const db = require('../database');
const { logTransactionAction } = require('../utils/auditLogger');
const { encrypt, decrypt } = require('../utils/encryption');

class Transaction {
  static async getAll() {
    const transactions = await db('transactions').select('*').orderBy('created_at', 'desc');
    return transactions.map(tx => Transaction.decryptFields(tx));
  }

  static async getAllWithUsers() {
    const transactions = await db('transactions')
      .select(
        'transactions.*',
        'users.full_name as user_full_name',
        'users.username as user_username'
      )
      .leftJoin('users', 'transactions.user_id', 'users.id')
      .orderBy('transactions.created_at', 'desc');
    return transactions.map(tx => Transaction.decryptFields(tx));
  }

  static async getById(id) {
    if (!Number.isInteger(Number(id)) || id <= 0) throw new Error('Invalid transaction ID');
    const tx = await db('transactions').where({ id }).first();
    return tx ? Transaction.decryptFields(tx) : null;
  }

  static async getByUserId(userId) {
    if (!Number.isInteger(Number(userId)) || userId <= 0) throw new Error('Invalid user ID');
    const txs = await db('transactions').where({ user_id: userId }).orderBy('created_at', 'desc');
    return txs.map(tx => Transaction.decryptFields(tx));
  }

  static async create({
    user_id,
    amount,
    currency,
    swift_code = null,
    recipient_name = null,
    provider = null,
    status = 'pending',
    description = ""
  }) {
    if (!Number.isInteger(Number(user_id)) || user_id <= 0) throw new Error('Invalid user ID');
    if (typeof amount !== 'number' || amount <= 0) throw new Error('Amount must be positive');
    const allowedCurrencies = ['ZAR', 'USD', 'EUR', 'GBP'];
    if (!allowedCurrencies.includes(currency)) throw new Error('Invalid currency');
    if (swift_code && !/^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$/.test(swift_code)) throw new Error('Invalid SWIFT code format');

    const sanitizedData = {
      user_id: parseInt(user_id),
      amount: parseFloat(amount),
      currency: currency.toUpperCase(),
      swift_code: swift_code ? encrypt(swift_code.toUpperCase()) : null,
      recipient_name: recipient_name ? encrypt(recipient_name.trim()) : null,
      provider: provider ? encrypt(provider.trim()) : null,
      status: status.toLowerCase(),
      description: description ? description.trim() : '',
      created_at: db.fn.now(),
      updated_at: db.fn.now()
    };

    const [id] = await db('transactions').insert(sanitizedData);
    const transaction = await db('transactions').where({ id }).first();
    await logTransactionAction(transaction.id, transaction.user_id, 'create', sanitizedData);
    return Transaction.decryptFields(transaction);
  }

  static async updateStatus(id, status) {
    if (!Number.isInteger(Number(id)) || id <= 0) throw new Error('Invalid transaction ID');
    const allowedStatuses = ['pending', 'verified', 'completed', 'failed', 'cancelled'];
    if (!allowedStatuses.includes(status)) throw new Error('Invalid status');

    const updated = await db('transactions')
      .where({ id })
      .update({ status: status.toLowerCase(), updated_at: db.fn.now() });

    if (updated > 0) {
      const transaction = await db('transactions').where({ id }).first();
      await logTransactionAction(id, transaction.user_id, 'update_status', { status });
      return Transaction.decryptFields(transaction);
    }
    return null;
  }

  static async update(id, updates) {
    if (!Number.isInteger(Number(id)) || id <= 0) throw new Error('Invalid transaction ID');
    const allowedFields = ['amount', 'currency', 'swift_code', 'recipient_name', 'provider', 'status', 'description'];
    const filteredUpdates = {};

    Object.keys(updates).forEach(key => {
      if (allowedFields.includes(key)) {
        if (key === 'currency') {
          const allowedCurrencies = ['ZAR', 'USD', 'EUR', 'GBP'];
          if (!allowedCurrencies.includes(updates[key])) throw new Error('Invalid currency');
          filteredUpdates[key] = updates[key].toUpperCase();
        } else if (['recipient_name', 'provider', 'swift_code'].includes(key)) {
          filteredUpdates[key] = updates[key] ? encrypt(updates[key].trim()) : null;
        } else if (['description'].includes(key)) {
          filteredUpdates[key] = updates[key].trim();
        } else if (key === 'status') {
          const allowedStatuses = ['pending', 'verified', 'completed', 'failed', 'cancelled'];
          if (!allowedStatuses.includes(updates[key])) throw new Error('Invalid status');
          filteredUpdates[key] = updates[key].toLowerCase();
        } else {
          filteredUpdates[key] = updates[key];
        }
      }
    });

    if (Object.keys(filteredUpdates).length === 0) throw new Error('No valid fields to update');
    filteredUpdates.updated_at = db.fn.now();

    const updated = await db('transactions').where({ id }).update(filteredUpdates);
    if (updated > 0) {
      const transaction = await db('transactions').where({ id }).first();
      await logTransactionAction(id, transaction.user_id, 'update', filteredUpdates);
      return Transaction.decryptFields(transaction);
    }
    return null;
  }

  static async delete(id) {
    if (!Number.isInteger(Number(id)) || id <= 0) throw new Error('Invalid transaction ID');
    const transaction = await db('transactions').where({ id }).first();
    const deleted = await db('transactions').where({ id }).del();
    if (deleted) await logTransactionAction(id, transaction.user_id, 'delete', {});
    return deleted;
  }

  static decryptFields(tx) {
    return {
      ...tx,
      recipient_name: tx.recipient_name ? decrypt(tx.recipient_name) : null,
      provider: tx.provider ? decrypt(tx.provider) : null,
      swift_code: tx.swift_code ? decrypt(tx.swift_code) : null
    };
  }
}

module.exports = Transaction;
